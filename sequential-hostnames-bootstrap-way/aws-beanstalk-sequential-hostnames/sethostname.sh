#!/bin/bash
#
# /tmp/cwlogs/sethostname.sh
# chmod 700 /tmp/cwlogs/sethostname.sh
#
# Running the script from .ebextension.yaml
# setsid /tmp/cwlogs/sethostname.sh `{"Ref":"AWSEBEnvironmentName"}` && exit 0;
# /usr/sbin/onboot.sh
#
# This script figures out a hostname based on the value of BeansTalk environment name.
# E.g, "someapp" would result in the hostname someapp-xxx
# where "xxx" is the next available number. The hostname is set locally and
# a CNAME record in Route53 can be created by separate Lambda Job.
# https://github.com/awslabs/aws-lambda-ddns-function
# Or my DDNS fork from this repo ../dns/aws-route53-dyndns
#
# The FQDN becomes HOSTNAME . ENVIRONMENT . DOMAIN
# (e.g. someapp-dev-000.mydomain)
#
# Finally the hostname is set on the "Name" tag of the ec2 instance
#
# Dependencies:
# This script assumes that the following
# packages are installed:
# * route53-cli
# * aws cli
# * ec2-metadata
#
# Tested on Amazon Linux BeansTalk AMI (Java and Node.js)
#
# Date: 2017-08-08
# Author: Vitalii Samotaiev <vsamotaev@glash.io>

# BEGIN CONFIGURATION
# Set these variables accordingly
DOMAIN=mydomain
AWS_REGION=us-east-1

echo "$1" > /etc/role
ROLE_FILE=/etc/role
EC2_METADATA=/opt/aws/bin/ec2-metadata
AWS=/usr/bin/aws
ROUTE53=/usr/bin/route53
HOSTNAME_CMD=/bin/hostname
LOGGER=/usr/bin/logger
CAT=/bin/cat
SED=/bin/sed
AWK=/bin/awk
PRINTF=/usr/bin/printf
CURL=/usr/bin/curl
# END CONFIGURATION
HOSTED_ZONE_ID=`$AWS route53 list-hosted-zones --output text --query "HostedZones[?Name == '$DOMAIN.'].[Id]" | cut -d "/" -f 3`
SYSTEM_ROLE=`[ -f $ROLE_FILE ] && $CAT $ROLE_FILE`
if [ -z $SYSTEM_ROLE ]; then
    exit 0
fi
app=${SYSTEM_ROLE%_*}
role=${SYSTEM_ROLE#*_}
app_lowercase=`echo "$app" | tr '[:upper:]' '[:lower:]'`
# hosts=`$ROUTE53 get $HOSTED_ZONE_ID | $AWK -v pattern=^$app_lowercase-.*.$DOMAIN '$0~pattern { printf $1 }'`
hosts=`$ROUTE53 get $HOSTED_ZONE_ID | $AWK -v pattern=^$app_lowercase-.*.$DOMAIN '$0~pattern { print $1 }'`;
IFS=$'\n' sorted=($(sort <<<"${hosts[*]}"))
hosts=($hosts)
ipv4=`$CURL -fs http://169.254.169.254/latest/meta-data/local-ipv4`
i=0
while [ true ]; do
    num=`$PRINTF "%03d" $i`
    hostname="$app_lowercase-$num"
    fqdn="$hostname.$DOMAIN"
    if [ "${hosts[$i]}" != "$fqdn." ]; then
        $SED -i "s/^HOSTNAME=.*$/HOSTNAME=$fqdn/" /etc/sysconfig/network
        $HOSTNAME_CMD $fqdn
        # Add fqdn to hosts file
        $CAT<<EOF > /etc/hosts
# This file is automatically generated by /usr/sbin/onboot.sh script
127.0.0.1 localhost
$ipv4 $fqdn $hostname
EOF
        $LOGGER "Setting hostname: $fqdn"
        $LOGGER "Creating CNAME record in Route53"
        ec2_public_hostname=`$EC2_METADATA -h | $SED 's/local-hostname: //'`
        ### $ROUTE53 add_record $HOSTED_ZONE_ID $fqdn CNAME $ec2_public_hostname 30 > /tmp/create-route53-cname.out
        break
    fi
    let i+=1
done

# Set hostname as "Name" tag
instance_id=`$EC2_METADATA -i | awk '{ print $2 }'`
#aws ec2 create-tags --region=$AWS_REGION --resources=$instance_id --tags Key=Name,Value=$hostname
# Set tags for ASG Route53 SNS CloudWatch Termination event updater
hostnamelowercase=`echo "$hostname" | tr '[:upper:]' '[:lower:]'`
tagcname=CNAME
tagcnamevalue="$hostnamelowercase.$DOMAIN."
tagzone=ZONE
tagzonevalue="$DOMAIN."
taghostname=Name
aws ec2 create-tags --region=$AWS_REGION --resources=$instance_id --tags Key=$tagcname,Value=$tagcnamevalue
aws ec2 create-tags --region=$AWS_REGION --resources=$instance_id --tags Key=$tagzone,Value=$tagzonevalue
aws ec2 create-tags --region=$AWS_REGION --resources=$instance_id --tags Key=$taghostname,Value=$tagcnamevalue